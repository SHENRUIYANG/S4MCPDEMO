FROM python:3.10-slim

WORKDIR /app

# 安装基础工具
RUN apt-get update && apt-get install -y git

# 复制项目文件
COPY requirements.txt .
COPY MRP.py .
COPY .env .
COPY MCPStandard.txt .

# 安装依赖（排除mcp，单独安装）
RUN pip install --no-cache-dir httpx>=0.25.0 requests>=2.31.0 openai>=1.6.0
RUN pip install --no-cache-dir python-dotenv uvicorn fastapi sse-starlette

# 从GitHub安装MCP SDK
RUN git clone https://github.com/modelcontextprotocol/python-sdk.git && \
    cd python-sdk && \
    pip install -e .

# 设置环境变量
ENV PORT=3000
ENV HOST=0.0.0.0

# 创建SSE服务器，专门实现MCP协议
RUN echo 'from fastapi import FastAPI, Request, Response\nfrom fastapi.responses import JSONResponse, StreamingResponse\nfrom fastapi.middleware.cors import CORSMiddleware\nimport json\nimport inspect\nimport asyncio\nimport uvicorn\nimport logging\nfrom MRP import mcp\nimport sys\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\napp = FastAPI()\n\n# 添加CORS支持\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\n@app.get("/")\ndef root():\n    return {"message": "MCP Server is running", "version": "1.0"}\n\n# 直接从MRP模块获取函数列表\n# 收集所有工具和提示词\ndef collect_tools_and_prompts():\n    tools = []\n    prompts = []\n    \n    # 调试输出\n    logger.info(f"MRP模块属性: {dir(mcp)}")\n    \n    # 查找所有方法\n    for name in dir(mcp):\n        if name.startswith("__"):\n            continue\n            \n        func = getattr(mcp, name)\n        logger.info(f"检查函数: {name}, 类型: {type(func)}, 属性: {dir(func)}")\n        \n        # 检查是否为工具函数\n        is_tool = False\n        is_prompt = False\n        \n        # 使用多种方式检测\n        if hasattr(func, "__mcp_tool__"):\n            is_tool = func.__mcp_tool__\n            logger.info(f"函数 {name} 通过__mcp_tool__属性识别为工具")\n        elif name in ["get_masterdata", "get_supplydemand", "get_coverage", "get_bom", \n                     "get_production_order_header", "get_production_order_component", \n                     "Get_PObyPO", "Get_POITEMbyPO"]:\n            is_tool = True\n            logger.info(f"函数 {name} 通过名称识别为工具")\n        \n        # 检查提示词\n        if hasattr(func, "__mcp_prompt__"):\n            is_prompt = func.__mcp_prompt__\n        elif name in ["mrp_analysis", "production_order_analysis"]:\n            is_prompt = True\n            logger.info(f"函数 {name} 通过名称识别为提示词")\n        \n        # 处理工具函数\n        if is_tool and callable(func):\n            params = {}\n            try:\n                sig = inspect.signature(func)\n                for param_name, param in sig.parameters.items():\n                    param_type = "string"  # 默认类型\n                    if param.annotation != inspect.Parameter.empty:\n                        if param.annotation == str:\n                            param_type = "string"\n                        elif param.annotation == int:\n                            param_type = "number"\n                        elif param.annotation == bool:\n                            param_type = "boolean"\n                    \n                    params[param_name] = {\n                        "type": param_type,\n                        "description": "",\n                        "required": param.default == inspect.Parameter.empty\n                    }\n                \n                tools.append({\n                    "name": name,\n                    "description": func.__doc__ or "",\n                    "parameters": params\n                })\n            except Exception as e:\n                logger.error(f"处理工具 {name} 时出错: {str(e)}")\n        \n        # 处理提示词函数\n        if is_prompt and callable(func):\n            try:\n                prompts.append({\n                    "name": name,\n                    "description": func.__doc__ or ""\n                })\n            except Exception as e:\n                logger.error(f"处理提示词 {name} 时出错: {str(e)}")\n    \n    logger.info(f"找到工具: {len(tools)}个, 提示词: {len(prompts)}个")\n    return tools, prompts\n\n# MCP SSE端点 - 实现标准MCP协议\n@app.get("/sse")\nasync def mcp_sse(request: Request):\n    async def event_stream():\n        try:\n            # 设置SSE headers\n            yield "data: " + json.dumps({"jsonrpc": "2.0", "method": "mcp:init", "params": {}}) + "\\n\\n"\n            \n            # 通知客户端服务器已准备好接收请求\n            tools, prompts = collect_tools_and_prompts()\n            yield "data: " + json.dumps({\n                "jsonrpc": "2.0", \n                "method": "mcp:ready", \n                "params": {\n                    "functions": tools,\n                    "prompts": prompts\n                }\n            }) + "\\n\\n"\n\n            # 保持连接\n            while True:\n                await asyncio.sleep(30)  # 每30秒发送一次ping\n                yield "data: " + json.dumps({"jsonrpc": "2.0", "method": "mcp:ping", "params": {}}) + "\\n\\n"\n        except asyncio.CancelledError:\n            logger.info("SSE连接已取消")\n            raise\n        except Exception as e:\n            logger.error(f"SSE连接错误: {str(e)}")\n            yield "data: " + json.dumps({\n                "jsonrpc": "2.0", \n                "error": {\n                    "code": -32000, \n                    "message": f"Internal error: {str(e)}"\n                }\n            }) + "\\n\\n"\n    \n    return StreamingResponse(\n        event_stream(),\n        media_type="text/event-stream",\n        headers={\n            "Cache-Control": "no-cache",\n            "Connection": "keep-alive",\n            "Content-Type": "text/event-stream",\n        },\n    )\n\n# 处理来自客户端的调用请求\n@app.post("/sse")\nasync def mcp_call(request: Request):\n    try:\n        data = await request.json()\n        request_id = data.get("id")\n        method = data.get("method")\n        params = data.get("params", {})\n        \n        logger.info(f"收到请求: {method} with id {request_id}")\n        \n        # 处理工具调用\n        if method == "mcp:call-function":\n            function_name = params.get("name")\n            function_args = params.get("arguments", {})\n            \n            # 检查函数是否存在\n            if hasattr(mcp, function_name) and callable(getattr(mcp, function_name)):\n                func = getattr(mcp, function_name)\n                try:\n                    result = await func(**function_args)\n                    return JSONResponse(content={\n                        "jsonrpc": "2.0",\n                        "id": request_id,\n                        "result": result\n                    })\n                except Exception as e:\n                    logger.error(f"工具调用错误: {str(e)}")\n                    return JSONResponse(content={\n                        "jsonrpc": "2.0",\n                        "id": request_id,\n                        "error": {\n                            "code": -32000,\n                            "message": f"Function error: {str(e)}"\n                        }\n                    })\n            \n            return JSONResponse(content={\n                "jsonrpc": "2.0",\n                "id": request_id,\n                "error": {\n                    "code": -32601,\n                    "message": f"Function {function_name} not found"\n                }\n            })\n        \n        # 处理prompt调用\n        elif method == "mcp:call-prompt":\n            prompt_name = params.get("name")\n            prompt_args = params.get("arguments", {})\n            \n            # 检查提示词是否存在\n            if hasattr(mcp, prompt_name) and callable(getattr(mcp, prompt_name)):\n                func = getattr(mcp, prompt_name)\n                try:\n                    result = func(**prompt_args)\n                    return JSONResponse(content={\n                        "jsonrpc": "2.0",\n                        "id": request_id,\n                        "result": {\n                            "prompt": result\n                        }\n                    })\n                except Exception as e:\n                    logger.error(f"Prompt调用错误: {str(e)}")\n                    return JSONResponse(content={\n                        "jsonrpc": "2.0",\n                        "id": request_id,\n                        "error": {\n                            "code": -32000,\n                            "message": f"Prompt error: {str(e)}"\n                        }\n                    })\n            \n            return JSONResponse(content={\n                "jsonrpc": "2.0",\n                "id": request_id,\n                "error": {\n                    "code": -32601,\n                    "message": f"Prompt {prompt_name} not found"\n                }\n            })\n        \n        # 处理列出工具\n        elif method == "mcp:list-tools":\n            tools, _ = collect_tools_and_prompts()\n            return JSONResponse(content={\n                "jsonrpc": "2.0",\n                "id": request_id,\n                "result": {\n                    "functions": tools\n                }\n            })\n        \n        # 处理列出提示词\n        elif method == "mcp:list-prompts":\n            _, prompts = collect_tools_and_prompts()\n            return JSONResponse(content={\n                "jsonrpc": "2.0",\n                "id": request_id,\n                "result": {\n                    "prompts": prompts\n                }\n            })\n        \n        else:\n            return JSONResponse(content={\n                "jsonrpc": "2.0",\n                "id": request_id,\n                "error": {\n                    "code": -32601,\n                    "message": f"Method {method} not found"\n                }\n            })\n        \n    except Exception as e:\n        logger.error(f"处理请求错误: {str(e)}")\n        return JSONResponse(content={\n            "jsonrpc": "2.0",\n            "id": None,\n            "error": {\n                "code": -32000,\n                "message": f"Server error: {str(e)}"\n            }\n        }, status_code=500)\n\nif __name__ == "__main__":\n    logger.info("启动MCP SSE服务器...")\n    # 确保能看到MRP中的函数\n    logger.info(f"MRP模块中的函数: {dir(mcp)}")\n    uvicorn.run(app, host="0.0.0.0", port=3000)\n' > mcp_server.py

# 暴露端口
EXPOSE 3000

# 使用新的服务器启动脚本
CMD ["python", "mcp_server.py"] 